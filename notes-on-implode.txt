// trying to map out how the input buffer changes over time

phase = 0
dsize_bytes = 0x400(1024) | 0x800(2048) | 0x1000(4096)
input_data_ended = false

------------ while(input_data_ended === false) ------------

// beolvasunk max 0x1000 byte adatot:

bytes_to_load = 0x1000
total_loaded = 0

while (bytes_to_load > 0) {
  read data: {
    pWork->work_buff + dsize_bytes + 0x204 + total_loaded
    pWork->work_buff + dsize_bytes + 0x204 + total_loaded + bytes_to_load
  } -> bytes_loaded

  if (bytes_loaded === 0) {
    if (total_loaded === 0 && phase === 0) {
      goto __Exit
    } else {
      input_data_ended = true
    }
  } else {
    total_loaded += bytes_loaded
  }
}

------------

if (input_data_ended) {
  input_data = {
    pWork->work_buff + dsize_bytes + 0x204
    pWork->work_buff + dsize_bytes + total_loaded + 0x204
  }
} else {
  input_data = {
    pWork->work_buff + dsize_bytes + 0x204
    pWork->work_buff + dsize_bytes + total_loaded
  }
}

============

switch(phase) {
  case 0: {
    if (input_data_ended) {
      tmp = {
        pWork->work_buff + dsize_bytes + 0x204
        pWork->work_buff + dsize_bytes + total_loaded + 0x204
      }
    } else {
      tmp = {
        pWork->work_buff + dsize_bytes + 0x204
        pWork->work_buff + dsize_bytes + total_loaded
      }
    }
    phase += dsize_bytes === 0x1000 ? 1 : 2
  }
  break
  case 1: {
    if (input_data_ended) {
      tmp = {
        pWork->work_buff + 0x204 + 0x204,
        pWork->work_buff + dsize_bytes + 0x204 + total_loaded
      }
    } else {
      tmp = {
        pWork->work_buff + 0x204 + 0x204,
        pWork->work_buff + dsize_bytes + total_loaded
      }
    }
    phase += 1
  }
  break
  default: {
    if (input_data_ended) {
      tmp = {
        pWork->work_buff + 0x204,
        pWork->work_buff + dsize_bytes + 0x204 + total_loaded
      }
    } else {
      tmp = {
        pWork->work_buff + 0x204,
        pWork->work_buff + dsize_bytes + total_loaded
      }
    }
  }
}

SortBuffer(state, tmp, tmp.length)

------------

while (input_data.length > 0) {

  let repetition_length = find repetition (pWork, input_data)
  while (repetition_length > 0) {
    // repetition_length changes over time!

    // the code also has breaks and a continue here
    // just before the continue:
    output bits(1 byte)
    input_data++
    continue
    
    __FlushRepetitions:
      output bits(? bytes)

    input_data += repetition_length
    goto __skip_one_byte_output
  }

  output bits(1 byte)
  input_data++

  __skip_one_byte_output:
    if (!input_data_ended) {
      input_data -= 0x1000;
      drop first 0x1000 bytes in pWork->work_buff
    }
}

------------------------ end while ------------------------

__Exit:

// Write the termination literal
